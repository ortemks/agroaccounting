import Joi from "joi";
import mongoose from "mongoose";

export function objectIdValidator(): Joi.Schema {
    let validator = Joi.alternatives(
        Joi.string().regex(/^[0-9a-fA-F]{24}$/, 'mongodb objectId string represention'),
        Joi.object().instance(mongoose.Types.ObjectId)
    );
    validator.type = 'objectId';
    return validator
}

export function findProperty(JoiSchema: Joi.Schema, schemaType = { optional: false, quantitative: false}): Joi.Schema {
    let alternatives = [ Joi.object().keys({
        in: Joi.array().min(1).items(JoiSchema),
        nin: Joi.array().min(1).items(JoiSchema),
    }), JoiSchema ];

    if (schemaType.quantitative) {
        (alternatives[0] as Joi.ObjectSchema) = (alternatives[0] as Joi.ObjectSchema).keys({
            gte: JoiSchema,
            lte: JoiSchema
        }).oxor('in', 'nin').oxor('lte', 'in').oxor('gte', 'in').or('in', 'nin', 'gte', 'lte') 
    } else {
        (alternatives[0] as Joi.ObjectSchema) = (alternatives[0] as Joi.ObjectSchema).xor('in', 'nin')
    }

    if (schemaType.optional) {
        alternatives.push( Joi.object().keys({
            exists: Joi.boolean().required()
        }))
    }

    return Joi.alternatives(...alternatives).optional();
}



/* 
let child = new mongoose.Schema({
    a: {
        type: [mongoose.SchemaTypes.ObjectId]
    },
    b: {
        type: mongoose.SchemaTypes.Number
    },
    c: [{
        type: mongoose.SchemaTypes.ObjectId
    }]
});

let newSchema = new mongoose.Schema({
    lol: {
        type: child
    },
    noLol: {
        type: [child]
    }
});

let valSchema = getValidationSchema(newSchema, "filter");       
let k = Joi.attempt( { lol: {a: ['61f11d5814b555fc955830e'], c: ['61f11d5814b555fc955830ed'], b: 3, _id: '61f11d5814b555fc955830ed' } }, valSchema, {stripUnknown: true});
console.log(k, 9);



type SchemaType = 'filter' | 'create' | 'update' | 'remove';
function getValidationSchema<DataType>(mongooseSchema: mongoose.Schema<DataType>, validationSchemaType: SchemaType, propertiesWithDifferentTypes: { name: keyof DataType, type: Joi.Schema }[] = [], autoGeneratedProperties?: keyof DataType ): Joi.Schema {
    let JoiSchemaPropertiesKeys = convertMongooseToJoiSchema(mongooseSchema);
    let filter = getFilterSchema(JoiSchemaPropertiesKeys);
    //console.log(filter['$_terms'].keys[0].schema['$_terms'].matches[1].schema['$_terms'].keys[0].schema['$_terms'].items[0]['$_terms'].keys[0], filter['$_terms'].keys[0].key)

    switch (validationSchemaType) {
        case "filter": 
            return filter;
        case "create": 
            for (let key in JoiSchemaPropertiesKeys) {
                if ( (mongooseSchema.path(key) as any).isRquired ) JoiSchemaPropertiesKeys[key] = JoiSchemaPropertiesKeys[key].required();
            }
        case "update":
            return Joi.object().keys({
                filter: filter.required(),
                update: getUpdateSchema(convertMongooseToJoiSchema(mongooseSchema)).required()
            })
        case "remove": 
            return filter
    }
}  


function convertMongooseToJoiSchema(mongooseSchema: mongoose.Schema) {
    let validationSchemaPropertiesKeys: { [key: string]: Joi.Schema } = {};

    mongooseSchema.eachPath( (pathName, pathType) => {
            function getValidationSchemaProperty (propertyType: mongoose.SchemaType): Joi.Schema {
                let newValidationSchemaProperty: Joi.Schema = Joi.any();

                let mongooseSchemaPropertyType = Object.getPrototypeOf(propertyType).constructor;
                switch (mongooseSchemaPropertyType) {
                    case mongoose.SchemaTypes.String:
                        newValidationSchemaProperty = Joi.string();
                        break;
                    case mongoose.SchemaTypes.Number:
                        newValidationSchemaProperty = Joi.number();
                        break;
                    case mongoose.SchemaTypes.ObjectId:
                        newValidationSchemaProperty = (Joi as any).objectId();
                        break;
                    case mongoose.SchemaTypes.Boolean:
                        newValidationSchemaProperty = Joi.boolean();
                        break;
                    case mongoose.SchemaTypes.Subdocument:
                        let nestedSchema = propertyType.schema;
                        newValidationSchemaProperty = Joi.object().keys(convertMongooseToJoiSchema(nestedSchema));

                        break;
                    case mongoose.SchemaTypes.Array:
                        let arrayItemValidationSchemaProperty = getValidationSchemaProperty((pathType as any).caster);
                        newValidationSchemaProperty = Joi.array().items(arrayItemValidationSchemaProperty);
                        break;
                    case mongoose.SchemaTypes.DocumentArray:
                        let arrayItemValidationSchemaPropertyKeys: { [key: string]: Joi.Schema } = {};
                        
                        let arrayItemSchema = propertyType.schema;
                        arrayItemSchema.eachPath( (pathName, pathType) => {
                            arrayItemValidationSchemaPropertyKeys[pathName] = getValidationSchemaProperty(pathType);
                        });

                        newValidationSchemaProperty = Joi.array().items(Joi.object().keys(arrayItemValidationSchemaPropertyKeys))
                        break;
                } 

                return newValidationSchemaProperty
            }

        validationSchemaPropertiesKeys[pathName] = getValidationSchemaProperty(pathType);
    })

    return validationSchemaPropertiesKeys
}

// filter schema 
function getFilterSchema(mongooseSchema: mongoose.Schema) {
    let validationSchemaPropertiesKeys: { [key: string]: Joi.AnySchema } = convertMongooseToJoiSchema(mongooseSchema);

    for (let key in validationSchemaPropertiesKeys) validationSchemaPropertiesKeys[key] = setPropertyFilter(validationSchemaPropertiesKeys[key], mongooseSchema.path(key)).optional();

    return Joi.object().keys(validationSchemaPropertiesKeys);
}


function setPropertyFilter(joiSchemaProperty: Joi.Schema, mongoosePathType: mongoose.SchemaType): Joi.AlternativesSchema {
    let filterAlternatives: [Joi.Schema, Joi.ObjectSchema] = [ joiSchemaProperty, Joi.object().keys({
        in: Joi.array().min(1).items(joiSchemaProperty),
        nin: Joi.array().min(1).items(joiSchemaProperty)
    }) ];

    if ( ['date', 'number'].includes(joiSchemaProperty.type as string) ) {
        filterAlternatives[1] = filterAlternatives[1].keys({ 
            gte: joiSchemaProperty,
            lte: joiSchemaProperty
        })
    }

    if (joiSchemaProperty.type === 'object') {
        filterAlternatives.push(getNestedObjectPropertyFilter(property as Joi.ObjectSchema));
    }
        
    if (joiSchemaProperty.type === 'array') {
        let arrayItemSchema: Joi.Schema = property['$_terms'].items[0];
        if (arrayItemSchema.type === 'object') { 
            arrayItemSchema = getNestedObjectPropertyFilter(arrayItemSchema as Joi.ObjectSchema); 
        };

        filterAlternatives[1] = filterAlternatives[1].keys({ 
            contains: Joi.array().min(1).items(arrayItemSchema),
            nContains: Joi.array().min(1).items(arrayItemSchema)
        });
    }

    return Joi.alternatives(...filterAlternatives);
}

function getNestedObjectProperty(nestedObjectProperty: Joi.ObjectSchema, mongoosePathType: mongoose.SchemaType) {
    let propertySchema = mongoosePathType.schema;
    let propertyCreationSchema = getCreationSchema(propertySchema);
    let schemaPropertiesKeys: { [key:string]: Joi.Schema } = {};

    let schemaPropertiesArray = nestedObjectProperty['$_terms'].keys as { key: string, schema: Joi.Schema }[];
    schemaPropertiesArray.forEach( property => schemaPropertiesKeys[property.key] = property.schema );

    return getFilterSchema(schemaPropertiesKeys)['$_terms'].keys[0]
}

// create schema 
function getCreationSchema(mongooseSchema: mongoose.Schema) {
    let validationSchemaPropertiesKeys = get
    for (let key in validationSchemaPropertiesKeys) {
        if ((mongooseSchema.path(key) as any)?.isRequired) validationSchemaPropertiesKeys[key] = validationSchemaPropertiesKeys[key].required()
    }
}
// update schema
function getUpdateSchema(validationSchemaPropertiesKeys: { [key: string]: Joi.AnySchema }):Joi.Schema {
    let keysCopy = Object.assign({}, validationSchemaPropertiesKeys); 

    for (let key in keysCopy) {
        let propertySchema = keysCopy[key];

        function getNestedObjectPropertyUpdateSchema (propertySchema: Joi.ObjectSchema) {
            let schemaPropertiesKeys: { [key:string]: Joi.Schema } = {};

            let schemaPropertiesArray = propertySchema['$_terms'].keys as { key: string, schema: Joi.Schema }[];
            schemaPropertiesArray.forEach( property => schemaPropertiesKeys[property.key] = property.schema );

            return getUpdateSchema(schemaPropertiesKeys)
        }

        if (propertySchema.type === 'object') { 
            propertySchema = getNestedObjectPropertyUpdateSchema(propertySchema as Joi.ObjectSchema);
        };

        if (propertySchema.type === 'array') {
            let arrayItemSchema: Joi.Schema = propertySchema['$_terms'].items[0];
            let arrayItemFilter = getFilterSchema({ arrayItem: arrayItemSchema })['$_terms'].keys[0].schema;

            let arrayUpdateAlternatives: [Joi.ArraySchema, Joi.ObjectSchema] = [propertySchema as Joi.ArraySchema, Joi.object().keys({
                add: Joi.array().min(1).items(arrayItemSchema),
                remove: arrayItemFilter
            }).or('add', 'remove')];

            if (arrayItemSchema.type === 'object') {
                let arrayItemUpdate = getNestedObjectPropertyUpdateSchema(arrayItemSchema as Joi.ObjectSchema);

                arrayUpdateAlternatives.push(Joi.object().keys({
                    filter: arrayItemSchema.required(),
                    update: arrayItemUpdate.required()
                }))
            }

            propertySchema = Joi.alternatives(...arrayUpdateAlternatives)
        }
    }

    return Joi.object().keys(keysCopy).or(...Object.keys(keysCopy)); 
} */